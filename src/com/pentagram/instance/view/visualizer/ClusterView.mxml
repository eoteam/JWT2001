<?xml version="1.0" encoding="utf-8"?>
<modules:Module xmlns:fx="http://ns.adobe.com/mxml/2009" 
				xmlns:s="library://ns.adobe.com/flex/spark" 
				xmlns:mx="library://ns.adobe.com/flex/mx"
				xmlns:modules="ws.tink.spark.modules.*"
				implements="com.pentagram.instance.view.visualizer.interfaces.IClusterView" 
				creationComplete="module1_creationCompleteHandler(event)"
				resize="handleResize(event)">
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	<fx:Script>
		<![CDATA[
			[Embed(source="/assets/fonts/FlamaBold.ttf", fontName="FlamaBookMx2",embedAsCFF="false",mimeType = "application/x-font")]
			private var _flamaBook:Class;
			
			import com.greensock.TweenNano;
			import com.pentagram.instance.view.visualizer.renderers.ClusterRenderer;
			import com.pentagram.instance.view.visualizer.renderers.MapRenderer;
			import com.pentagram.model.vo.Category;
			import com.pentagram.model.vo.DataRow;
			import com.pentagram.model.vo.Dataset;
			
			import flash.display.Sprite;
			import flash.events.Event;
			import flash.events.MouseEvent;
			import flash.geom.Point;
			import flash.geom.Vector3D;
			
			import mx.events.FlexEvent;
			import mx.events.ResizeEvent;
			
			import spark.core.SpriteVisualElement;
			
			protected var _nodes:Vector.<MapRenderer> = new Vector.<MapRenderer>;  
			private var iterationCounter:int = 0;
			private var CENTER:Point;
			private var v:Vector3D;
			private var ds:Dataset;
			private var maxRadius:Number = 25;
			private var firstLoad:Boolean = true;
			private var ds1:Dataset;
			private var ds2:Dataset;
			
			public function get datasets():Array {
				return [null,null,ds1,ds2];
			}
			public function visualize(dataset1:Dataset,dataset2:Dataset=null):void {
				this.ds1 = dataset1; this.ds2 = dataset2;
				if(!firstLoad) {
					doVisualize();
				}
			}
			private function doVisualize():void {
				this.removeAllElements();
				if(ds1.type == 0) { //quantitative
					for each(var item:Category in ds1.optionsArray) {
						item.selected = item.enabled = true;
						var parent:SpriteVisualElement = new SpriteVisualElement();
						parent.percentHeight = parent.percentWidth = 100;
						this.addElement(parent);
						
						var arr:Array = [];
						var r:Number = 1;
						for each(var row:DataRow in ds1.rows) {
							var value:String = ds1.time == 1 ? row[ds1.years[0]] : row.value;
							if(value == item.name) {
								if(ds2 && ds2.type == 1) {
									var row2:DataRow = ds2.rows.getItemAt(ds1.rows.getItemIndex(row)) as DataRow;
									if(ds2.time == 1)
										r = (row2[ds2.years[0]] - ds2.min) / (ds2.max - ds2.min) * maxRadius;
									else
										r = (row2.value - ds2.min) / (ds2.max - ds2.min) * maxRadius;	
								}	
								arr.push({data:row,radius:r,color:item.color,data2:row2});
							}	
						}
						var circle:CirclePacking = new CirclePacking(arr);
						circle.name = item.name;
						circle.x = width/(ds1.optionsArray.length*2);
						circle.width = width/ds1.optionsArray.length;
						circle.y = height/2;
						circle.height = height;
						parent.addChild(circle);
						this.callLater(function resumeDraw(c:CirclePacking):void {c.doLayout()},[circle]);
					} 
				}
				firstLoad = false;
			}
			public function update():void {
				
			}
			
			public function updateMaxRadius(value:Number):void {
				for (var i:int=0;i<this.numElements;i++) {
					var parent:SpriteVisualElement = this.getElementAt(i) as SpriteVisualElement;
					var c:CirclePacking = parent.getChildAt(0) as CirclePacking;
//					for each(var r:ClusterRenderer in c.spriteArray) {
//						r.radiusBeforeRendering = r.radiusBeforeRendering / maxRadius * newRadius;
//					}
					c.scaler = value/100;
					//c.layout();
					c.draw();
				}
			}
			
			public function unload():void {
				
			}
						
			private var _continous:Boolean = false;
			public function get continous():Boolean{
				return _continous;
			}			
			public function set continous(value:Boolean):void{
				_continous = value;
			}
			
			public function pause():void  {
				
			}
			
			public function resume():void {
				
			}
			
			public function updateYear(year:int):void {
				for (var i:int=0;i<this.numElements;i++) {
					var parent:SpriteVisualElement = this.getElementAt(i) as SpriteVisualElement;
					var c:CirclePacking = parent.getChildAt(0) as CirclePacking;
					for (var j:int=0;j<c.numChildren;j++) {
						var circle:ClusterRenderer = c.getChildAt(j) as ClusterRenderer;
						if(ds2.time == 1 && year >= ds2.years[0] && year <= ds2.years[1]) {
							circle.radiusBeforeRendering =  (circle.data2[year.toString()] - ds2.min) / (ds2.max - ds2.min) * maxRadius;	
							trace(circle.radiusBeforeRendering);
						}	
//						if(ds1.time == 1 && year >= ds2.years[0] && year <= ds2.years[1])
//						{
//							circle.includeInLayout = false;
//						}
							
					}
					c.doLayout();
					//c.draw();
					
				}
			}
			public function toggleCategory(visible:Boolean,prop:String):void {
				
			}
			private function module1_creationCompleteHandler(event:FlexEvent):void {
				this.doVisualize();
			}
			public function toggleOpacity(value:Number):void {

			}	
			public function updateSize():void {
				this.callLater(handleResize);
			}
			public function addCategory(value:Category):void {
				for (var i:int=0;i<this.numElements;i++) {
					var parent:SpriteVisualElement = this.getElementAt(i) as SpriteVisualElement;
					var c:CirclePacking = parent.getChildAt(0) as CirclePacking;
					if(c.name == value.name) {
						parent.visible = true;
						parent.includeInLayout = true;
						break;
					}
				}
				this.callLater(handleResize);
			}
			
			public function removeCategory(value:Category):void {
				for (var i:int=0;i<this.numElements;i++) {
					var parent:SpriteVisualElement = this.getElementAt(i) as SpriteVisualElement;
					var c:CirclePacking = parent.getChildAt(0) as CirclePacking;
					if(c.name == value.name) {
						parent.visible = false;
						parent.includeInLayout = false;
						break;
					}
				}
				this.callLater(handleResize);
			}
			public function selectCategory(value:Category):void {
				for (var i:int=0;i<this.numElements;i++) {
					var parent:SpriteVisualElement = this.getElementAt(i) as SpriteVisualElement;
					var c:CirclePacking = parent.getChildAt(0) as CirclePacking;
					if(c.name != value.name) {
						parent.visible = false;
						parent.includeInLayout = false;
					}
					else {
						parent.visible = true;
						parent.includeInLayout = true;
						c.resize();
					}
				}
			}
			private function handleResize(event:Event=null):void
			{
				for (var i:int=0;i<this.numElements;i++) {
					var parent:SpriteVisualElement = this.getElementAt(i) as SpriteVisualElement;
					if(parent.visible) {
						var c:CirclePacking = parent.getChildAt(0) as CirclePacking;
						c.x = parent.width/2;
						c.width = parent.width;
						c.y = parent.height/2;
						c.height = parent.height;
						c.draw();
					}
				}
			}
			

		]]>
	</fx:Script>

		<modules:layout>
			<s:HorizontalLayout gap="2" verticalAlign="middle" />
		</modules:layout>		

</modules:Module>
