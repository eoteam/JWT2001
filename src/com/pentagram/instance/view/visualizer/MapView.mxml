<?xml version="1.0" encoding="utf-8"?>
<modules:Module xmlns:fx="http://ns.adobe.com/mxml/2009" 
				xmlns:s="library://ns.adobe.com/flex/spark"  width="100%" height="100%"
				xmlns:mx="library://ns.adobe.com/flex/mx"  clipAndEnableScrolling="true"
				xmlns:modules="ws.tink.spark.modules.*" contentBackgroundColor="0xff0000"
				implements="com.pentagram.instance.view.visualizer.IMapView">
	
	<fx:Script>
		<![CDATA[
			import com.pentagram.model.vo.DataRow;
			import com.pentagram.model.vo.Dataset;
			import com.pentagram.util.ViewUtils;
			
			import flare.animate.Scheduler;
			import flare.animate.TransitionEvent;
			import flare.animate.Transitioner;
			import flare.display.DirtySprite;
			import flare.scale.ScaleType;
			import flare.util.palette.SizePalette;
			import flare.vis.Visualization;
			import flare.vis.data.Data;
			import flare.vis.data.DataSprite;
			import flare.vis.events.TooltipEvent;
			import flare.vis.operator.encoder.ColorEncoder;
			import flare.vis.operator.encoder.PropertyEncoder;
			import flare.vis.operator.encoder.SizeEncoder;
			import flare.vis.operator.layout.AxisLayout;
			
			import mx.events.ResizeEvent;
			
			private var vis:Visualization;

			
			public function toggleMap(visible:Boolean):void {
				if(map)
					map.visible = visible;
			}
			private var firstPass:Boolean = true;
			public function visualize(dataset:Dataset):void {
				
				var axisLayout:AxisLayout;
				var colorEncoder:ColorEncoder;
				var propEncoder:PropertyEncoder;
				var sizeEncoder:SizeEncoder;
				var sizePalette:SizePalette = new SizePalette(1,20);
				var sizeSource:String;
				visdata = Data.fromArray(dataset.rows.source);
				
				if(firstPass) {
					axisLayout = new AxisLayout("data.xcoord", "data.ycoord");	
					propEncoder = new PropertyEncoder({lineAlpha: 1, alpha:0.75, buttonMode: true, size: 1});
					colorEncoder = new ColorEncoder("data.country.region.color", Data.NODES,"fillColor", ScaleType.CATEGORIES);
					
					if(dataset.time) 
						sizeSource = "data."+dataset.years[0].toString();
					else
						sizeSource = "data.value";
						
					sizeEncoder = new SizeEncoder(sizeSource, Data.NODES,sizePalette);
					var bounds:Rectangle =  new Rectangle(this.width*.2, 0, this.width, this.height);
					
					vis = new Visualization();
					vis.continuousUpdates = true;
					vis.x = 0; 
					vis.y = 0;
					vis.bounds = bounds;
					
					holder.rawChildren.addChild(vis);
					this.addEventListener(ResizeEvent.RESIZE,group1_resizeHandler);
					
					vis.data = _visdata;
					firstPass = false;
					
					vis.operators.add(axisLayout);
					vis.operators.add(propEncoder);
					vis.operators.add(sizeEncoder);
					vis.operators.add(colorEncoder);
					
					// add tooltip showing data values
					vis.controls.add(new  ViewTooltipControl(DataSprite, null,
						function(evt:TooltipEvent):void {
							var d:DataSprite = evt.node;
							DataTooltip(evt.tooltip).row = d.data as DataRow;
							//TextSprite(evt.tooltip).htmlText = 
							//Strings.format(_tipText, d.data.s, d.data.y, d.data.x);
						}
					));
					
					vis.xyAxes.visible = false;	
					vis.axes.visible = false;
					vis.xyAxes.showBorder = false;
					vis.xyAxes.showXLine = false;
					vis.xyAxes.showYLine = false;
					vis.xyAxes.xAxis.showLines = false;
					vis.xyAxes.yAxis.showLines = false;
					vis.xyAxes.yAxis.showLabels = false;		
					vis.xyAxes.xAxis.showLabels = false;		
					ViewUtils.executeLater(pause);
				}
				else {
					vis.bounds = new Rectangle(0, 0, this.width-100, this.height-100);
					sizeEncoder = vis.operators.getOperatorAt(2) as SizeEncoder;
					if(dataset.time)
						sizeSource = "data."+dataset.years[0].toString();
					else
						sizeSource = "data.value";
					sizeEncoder.scale.data = _visdata;
					sizeEncoder.source = sizeSource;
					vis.data = _visdata;
					resume();
					resumeUpdate();
					
				}
			}
			private var _visdata:Data;
			public function set visdata(d:Data):void {
				_visdata = d;
			}
			public function get visdata():Data {
				return _visdata;
			}
			
			private var _continous:Boolean = false;
			public function get continous():Boolean{
				return _continous;
			}			
			public function set continous(value:Boolean):void{
				_continous = value;
				if(_continous == false) {
					pause();
				}
				else {
					resume();
				}
			}
			public function unload():void {
				if(vis) {
					Scheduler.instance.remove(vis.rec);
					vis = null;
				}
			}			
			public function resume():void {
				DirtySprite.resume();
				Scheduler.instance.play();
				vis.resume();
			}
			public function pause():void {
				DirtySprite.pause();
				Scheduler.instance.pause();
				vis.pause();				
			}
			public function updateMaxRadius(value:Number):void {
//				var sizeEncoder:SizeEncoder = vis.operators.getOperatorAt(2) as SizeEncoder;
//				SizePalette(sizeEncoder.palette).maximumSize = value;
//				resume();
//				this.callLater(function resumeUpdate():void {
//					var t:Transitioner = new Transitioner(1);
//					t.addEventListener(TransitionEvent.END,handleEnd);
//					vis.update(t).play();
//				});
//				
			}
			public function updateYear(year:int):void {
				var sizeEncoder:SizeEncoder = vis.operators.getOperatorAt(2) as SizeEncoder;
				sizeEncoder.source = "data."+year.toString();
				update();
			}
			public function update():void {
				if(!_continous)
					resume();
				resumeUpdate();
			}
			private function handleEnd(event:Event=null):void {
				if(!_continous) {
					ViewUtils.executeLater(pause,null,2500);
				}
			}
			private function group1_resizeHandler(event:ResizeEvent):void {
				if(!firstPass) {
					vis.bounds = new Rectangle(this.width*.1, this.height*.005, this.width, this.height);
					resume();
					ViewUtils.executeLater(coldUpdate).addEventListener("executed",handleUpdateComplete); 
				}
			}
			private function resumeUpdate():void {		
				var t:Transitioner = new Transitioner(2.5);
				t.addEventListener(TransitionEvent.END,handleEnd);
				vis.update(t).play();
			}
			private function coldUpdate():void {
				vis.update();
			}
			private function handleUpdateComplete(event:Event):void {
				ViewUtils.executeLater(handleEnd);
			}
			
		]]>
	</fx:Script>
	<fx:Declarations>
		<s:Fade alphaTo="1" duration="500" id="fadeIn" />
		<s:Fade alphaTo="0" duration="500" id="fadeOut" />
	</fx:Declarations>
	
	
	<mx:Image scaleContent="true" maintainAspectRatio="false" width="100%" height="100%" 
			  showEffect="{fadeIn}" hideEffect="{fadeOut}" id="map"	 alpha="0.8"	
			  source="assets/map.png"   />
	
	<mx:Canvas id="holder" width="100%" height="100%" />
</modules:Module>
	