<?xml version="1.0" encoding="utf-8"?>
<modules:Module xmlns:fx="http://ns.adobe.com/mxml/2009" 
				xmlns:s="library://ns.adobe.com/flex/spark"  width="100%" height="100%"
				xmlns:mx="library://ns.adobe.com/flex/mx"  clipAndEnableScrolling="true"
				xmlns:modules="ws.tink.spark.modules.*" contentBackgroundColor="0xff0000" 
				resize="handleResize(event)" 
				creationComplete="module1_creationCompleteHandler(event)"
				implements="com.pentagram.instance.view.visualizer.interfaces.IMapView" 
				xmlns:assets="assets.*" 
				xmlns:maps="assets.maps.*" 
				xmlns:visualizer="com.pentagram.instance.view.visualizer.*" xmlns:layouts="com.pentagram.view.layouts.*">
	
	<fx:Script>
		<![CDATA[
			
			[Embed(source="/assets/fonts/FlamaBold.ttf", fontName="FlamaBookMx2",embedAsCFF="false",mimeType = "application/x-font")]
			private var _flamaBook:Class;
			
			import com.greensock.TweenNano;
			import com.pentagram.instance.view.visualizer.renderers.MapRenderer;
			import com.pentagram.model.vo.Category;
			import com.pentagram.model.vo.Client;
			import com.pentagram.model.vo.Country;
			import com.pentagram.model.vo.DataRow;
			import com.pentagram.model.vo.Dataset;
			import com.pentagram.model.vo.Region;
			import com.pentagram.utils.CallTimer;
			
			import mx.events.FlexEvent;
			import mx.events.ResizeEvent;
			
			private var renderers:Vector.<MapRenderer>;
			private var renderersDictionary:Dictionary;
			private var maxRadius:Number = 25;
			
			private var currentYear:int;
			private const PATH:String = "assets/maps/";
			
			private var dataset:Dataset;
			private var  ds2:Dataset;
			
			public function get datasets():Array {
				return [null,null,dataset,null];
			}
			
			public function toggleMap(visible:Boolean):void {
				if(mapHolder) {
					var a:int = visible?1:0;
					TweenNano.to(mapHolder,.5,{alpha:a});
				}
			}
			public function updateSize():void {
				this.callLater(handleResize);
			}
			private var firstPass:Boolean = true;
			private var firstLoad:Boolean = true;
			public function set client(value:Client):void {
				renderers = new Vector.<MapRenderer>;
				renderersDictionary = new Dictionary();
				for each(var country:Country in value.countries.source) {
					var c:MapRenderer = new MapRenderer();
					c.id = country.shortname;				
					holder.addElement(c);				
					renderers.push(c);
					renderersDictionary[country.shortname] = c;
					c.state = false;
				}
			}
			public function visualize(dataset:Dataset):void {
				
				this.dataset = dataset;
				if(!firstLoad) {
					doVisualize();
				}
			}
			private function doVisualize():void {
				var r:Number;
				var c:MapRenderer;
				var row:DataRow;
				
				var world:FXGLoader = mapHolder.getElementAt(0) as FXGLoader;
				
				for each(row in dataset.rows) {
					if(dataset.type == 1) {
						if(dataset.time == 1) {
							r = (row[dataset.years[0]] - dataset.min) / (dataset.max - dataset.min) * maxRadius as Number;
							currentYear = dataset.years[0];
						}
						else
							r = (row.value - dataset.min) / (dataset.max - dataset.min) * maxRadius as Number;
					}
					c = renderersDictionary[row.country.shortname];
					if(c) {
						if(world.countries[row.country.shortname]) {
							c.countrySprite = world.countries[row.country.shortname];
							if(firstLoad)
								c.alpha = 0;
							c.state = true;
							c.textColor == c.fillAlpha == 1 ? 0xffffffff : c.fillColor;
							c.dirtyCoordinates();
							c.dirty();
						}	
						c.data = row;
						c.radius = r;
					}
				}
				firstLoad = false;
				firstPass = false;
			}
			private var _continous:Boolean = false;
			public function get continous():Boolean{
				return _continous;
			}			
			public function set continous(value:Boolean):void{
				_continous = value;
				if(_continous == false) {
					pause(); 
				}
				else {
					resume();
				}
			}
			public function unload():void {
				
			}			
			public function resume():void {
				
			}
			public function pause():void {
				
			}
			public function updateMaxRadius(value:Number):void {
				this.maxRadius = value;
				update();
			}
			public function updateYear(year:int):void {
				this.currentYear = year;
				update();
				
			}
			public function update():void {
				
				for each(var c:MapRenderer in renderers) {
					var r:Number;
					if(dataset.time == 1)
						r = (c.data[currentYear] - dataset.min) / (dataset.max - dataset.min) * maxRadius;
					else 
						r = (c.data.value - dataset.min) / (dataset.max - dataset.min) * maxRadius;
					TweenNano.to(c, .5, {radius: r});
					c.textColor = c.fillAlpha == 1 ? 0xffffffff : c.fillColor ;
				}
				
			}
			public function removeCategory(value:Category):void {
				var region:Region = value as Region;
				total -= region.coeff;
				for (var i:int=0;i<mapHolder.numElements;i++) {
					total += FXGLoader(mapHolder.getElementAt(i)).region.coeff;
				}
				slice = 100/total;
				for (i=0;i<mapHolder.numElements;i++) {
					FXGLoader(mapHolder.getElementAt(i)).percentWidth = FXGLoader(mapHolder.getElementAt(i)).region.coeff*slice;
				}
				for (i=0;i<mapHolder.numElements;i++) {
					var map:FXGLoader = mapHolder.getElementAt(i) as FXGLoader;
					if(map.region.fxgmap == region.fxgmap)
						mapHolder.removeElement(map);
				}
				handleResize();
			}
			public function selectCategory(value:Category):void {
				var existingMap:FXGLoader;
				var region:Region = value as Region;
				
				for (var i:int=0;i<mapHolder.numElements;i++) {
					var map:FXGLoader = mapHolder.getElementAt(i) as FXGLoader;
					if(map.region.fxgmap != region.fxgmap)
						mapHolder.removeElement(map);
					else 
						existingMap = map;
				}
				if(existingMap) {
					TweenNano.to(existingMap, .5, {width: mapHolder.width,height:mapHolder.height,onComplete:onFinishTween,onCompleteParams:[existingMap]});
					adjustRenderers();
				}
				else {
					map = new FXGLoader();
					map.addEventListener(Event.COMPLETE,handleMapLoaded);
					mapHolder.addElement(map);
					var file:File = File.applicationDirectory;
					file = file.resolvePath(PATH+region.fxgmap);
					map.load(file,region);
					map.percentHeight = 100;
					map.percentWidth = 100;
				}
				
			}
			private function onFinishTween(map:FXGLoader):void {
				map.percentHeight = map.percentWidth = 100;
			}
			//priv
			private function adjustRenderers():void {
				if(!firstPass) {
					var visibleItems:Array = [];
					var c:MapRenderer;
					for (var i:int=0;i<mapHolder.numElements;i++) {
						var map:FXGLoader = mapHolder.getElementAt(i) as FXGLoader;
						for each(var countrySprite:Shape in map.countries) {
							c = renderersDictionary[countrySprite.name];						
							if(c && c.data.country.region.fxgmap == map.region.fxgmap) {
								c.textColor = c.fillAlpha == 1 ? 0xffffffff : c.fillColor ;
								c.countrySprite = countrySprite;
								c.state = true;
								c.dirtyCoordinates();
								c.dirty();
								visibleItems.push(c);
							}
						}
					}
					for each(c in renderers) {
						if(visibleItems.indexOf(c) == -1)
							c.state = false;
					}
				}
			}
			private var total:Number ;
			private var slice:Number = 0;
			public function addCategory(value:Category):void {
				var region:Region = value as Region;
				var map:FXGLoader;
				if(mapHolder.numElements >= 3) {
					mapHolder.removeAllElements();
					loadWorldMap();
				}
				else {
					if(mapHolder.numElements == 1 && FXGLoader(mapHolder.getChildAt(0)).region.fxgmap == "world_map.xml")
						return;
					
					total = region.coeff;
					for (var i:int=0;i<mapHolder.numElements;i++) {
						total += FXGLoader(mapHolder.getElementAt(i)).region.coeff;
					}
					slice = 100/total;
					for (i=0;i<mapHolder.numElements;i++) {
						FXGLoader(mapHolder.getElementAt(i)).percentWidth = FXGLoader(mapHolder.getElementAt(i)).region.coeff*slice;
					}
					map = new FXGLoader();
					map.addEventListener(Event.COMPLETE,handleMapLoaded);
					mapHolder.addElement(map);
					map.percentHeight = 100;
					map.percentWidth = region.coeff*slice;
					var file:File = File.applicationDirectory;
					file = file.resolvePath(PATH+region.fxgmap);
					map.load(file,region);	
				}
			}
			public function toggleOpacity(value:Number):void {
				for each(var renderer:MapRenderer in renderers) {
					renderer.textColor = value==1 ?0xffffffff:renderer.fillColor;
					TweenNano.to(renderer, .5, {fillAlpha: value});
				}
			}
			private function handleResize(event:ResizeEvent=null):void {
				//var maxW:Number = 0;
				var maxW:Number = 0;
				var widestSprite:Sprite;
				var widestRegion:Region;
				var i:int = 0;
				var child:FXGLoader;
				var fxgSprite:Sprite;
				var fxgRatio:Number;
				var ratio:Number;
				var sx:Number;
				var sy:Number;
				var matr:Matrix;
				if(!firstPass) {
					for each(var c:MapRenderer in renderers) {
						if(c.state)
							c.dirtyCoordinates();
					}
				}
				if(mapHolder.numElements > 1) {					
					for (i=0;i<mapHolder.numElements;i++) {
						child = mapHolder.getElementAt(i) as FXGLoader;
						fxgSprite = child.fxgSprite;
						//						child.graphics.clear();
						//						child.graphics.beginFill(0xff6666,1);
						//						child.graphics.drawRect(0,0,child.width,child.height);
						//						child.graphics.endFill();
						var g:Sprite = fxgSprite.getChildAt(0) as Sprite;  
						if(g.width > maxW) {
							maxW = g.width;
							widestSprite = g;
							widestRegion = child.region;							
						}
						//						if(g.width < minW) {
						//
						//						}
					}
					if(mapHolder.numElements > 0) {
						var nw:Number; var nh:Number;   
						trace(widestRegion.width , widestRegion.height, widestRegion.coeff);
						fxgRatio = widestRegion.width / widestRegion.height;
						ratio = (mapHolder.width/(slice*widestRegion.coeff/100))/ mapHolder.height;  
						
						if(ratio >= fxgRatio) {
							nh = mapHolder.height;
							nw = nh*fxgRatio;
						}
						else {
							nw = mapHolder.width / (slice*widestRegion.coeff/100);
							nh = nw/fxgRatio;
						}
						sx = nw/widestSprite.width;
						sy = nh/widestSprite.height;
						
						for (i=0;i<mapHolder.numElements;i++) {
							child = mapHolder.getElementAt(i) as FXGLoader;
							fxgSprite = child.fxgSprite;
							matr = Sprite(fxgSprite.getChildAt(0)).transform.matrix;	
							matr.scale(sx, sy);
							fxgSprite.transform.matrix = matr;
							fxgSprite.x = (child.width / 2) - (fxgSprite.width / 2 );
							fxgSprite.y = (child.height / 2) - (fxgSprite.height / 2);
						}
					}
				}
				else if(mapHolder.numElements == 1) {
					child = FXGLoader(mapHolder.getElementAt(0)) as FXGLoader;
					fxgSprite = child.fxgSprite;
					widestSprite = fxgSprite.getChildAt(0) as Sprite;
					fxgRatio = fxgSprite.width / fxgSprite.height;
					ratio =  mapHolder.width/ mapHolder.height;  
					if(ratio >= fxgRatio) {
						nh = mapHolder.height;
						nw = nh*fxgRatio;
					}
					else {
						nw = mapHolder.width;
						nh = nw/fxgRatio;
					}
					sx = nw/widestSprite.width;
					sy = nh/widestSprite.height;
					
					matr = widestSprite.transform.matrix;
					matr.scale(sx, sy);
					fxgSprite.transform.matrix = matr;
					fxgSprite.x = (child.width / 2) - (fxgSprite.width / 2 );
					fxgSprite.y = (child.height / 2) - (fxgSprite.height / 2);
				}
			}
			private function module1_creationCompleteHandler(event:FlexEvent):void {	
				loadWorldMap();
			}
			private function handleMapLoaded(event:Event):void {
				FXGLoader(event.target).removeEventListener(Event.COMPLETE,handleMapLoaded);
				if(firstLoad) {
					doVisualize();
				}
				var timer:CallTimer = new CallTimer(resumeLoad,[event.target],250,1);
				timer.start();
			}
			private function resumeLoad(args:Array):void {
				handleResize();
				TweenNano.to(args[0],0.5,{alpha:1});
				if(FXGLoader(args[0]).region.fxgmap != "world_map.xml")
					adjustRenderers();
				else
					displayAllRenderers();
			}
			private function displayAllRenderers():void {
				if(!firstPass) {
					var map:FXGLoader = mapHolder.getElementAt(0) as FXGLoader;
					for each(var countrySprite:Shape in map.countries) {
						var c:MapRenderer = renderersDictionary[countrySprite.name];
						if(c) {
							c.countrySprite = countrySprite;
							c.state = true;
							c.textColor = c.fillAlpha == 1 ? 0xffffffff : c.fillColor ;
							c.dirtyCoordinates();
							c.dirty();
						}
					}
				}
			}
			private function loadWorldMap():void {
				var map:FXGLoader = new FXGLoader();
				map.addEventListener(Event.COMPLETE,handleMapLoaded);
				mapHolder.addElement(map);				
				var file:File = File.applicationDirectory;
				file = file.resolvePath(PATH+"world_map.xml");
				var r:Region = new Region();
				r.coeff = 1; r.fxgmap = "world_map.xml";
				map.load(file,r);
				map.percentHeight = 100;
				map.percentWidth = 100;
			}
		]]>
	</fx:Script>
	<fx:Declarations>
		<s:Fade alphaTo="1" duration="500" id="fadeIn" />
		<s:Fade alphaTo="0" duration="500" id="fadeOut" />
		
	</fx:Declarations>
	
	<s:HGroup width="100%" height="100%"  id="mapHolder" gap="2" />
	<s:Group id="holder" width="100%" height="100%" />
	
</modules:Module>
