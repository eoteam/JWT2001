<?xml version="1.0" encoding="utf-8"?>
<modules:Module xmlns:fx="http://ns.adobe.com/mxml/2009" 
				xmlns:s="library://ns.adobe.com/flex/spark"  width="100%" height="100%"
				xmlns:mx="library://ns.adobe.com/flex/mx"  clipAndEnableScrolling="true"
				xmlns:modules="ws.tink.spark.modules.*" contentBackgroundColor="0xff0000" 
				resize="module1_resizeHandler(event)" creationComplete="module1_creationCompleteHandler(event)"
				implements="com.pentagram.instance.view.visualizer.interfaces.IMapView" 
				xmlns:assets="assets.*" 
				xmlns:maps="assets.maps.*" 
				xmlns:visualizer="com.pentagram.instance.view.visualizer.*" xmlns:layouts="com.pentagram.view.layouts.*">
	
	<fx:Script>
		<![CDATA[
			import com.greensock.TweenNano;
			import com.pentagram.instance.view.visualizer.renderers.CircleSprite;
			import com.pentagram.model.vo.DataRow;
			import com.pentagram.model.vo.Dataset;
			
			import mx.events.FlexEvent;
			import mx.events.ResizeEvent;
			
			protected var renderers:Vector.<CircleSprite> = new Vector.<CircleSprite>;
			protected var maxRadius:Number = 25;
			protected var dataset:Dataset;
			protected var currentYear:int;
			
			public function toggleMap(visible:Boolean):void {
				if(mapHolder)
				mapHolder.visible = visible;
			}
			private var firstPass:Boolean = true;
			public function visualize(dataset:Dataset):void {
				this.dataset = dataset;
				trace(dataset.max,dataset.min,"\n","=#=#=#=#===###");
				var r:Number;
				var c:CircleSprite;
				var row:DataRow;
				
				for each(row in dataset.rows) {
					var x:Number = row.xcoord*width/939.747;
					var y:Number = row.ycoord*height/394.863;
					if(dataset.type == 1) {
						if(dataset.time == 1) {
							r = (row[dataset.years[0]] - dataset.min) / (dataset.max - dataset.min) * maxRadius as Number;
							currentYear = dataset.years[0];
						}
						else
							r = (row.value - dataset.min) / (dataset.max - dataset.min) * maxRadius as Number;
					}
					if(firstPass) {
						c = new CircleSprite(row,[row.country.region.color,row.country.region.color],r,x,y);
						c.id = dataset.rows.getItemIndex(row).toString();
						holder.addElement(c);
						renderers.push(c);
					}
					else {
						c = holder.getElementAt(dataset.rows.getItemIndex(row)) as CircleSprite;
						c.data = row;
						c.radius = r;
					}
				}
				firstPass = false;
			}
			
			private var _continous:Boolean = false;
			public function get continous():Boolean{
				return _continous;
			}			
			public function set continous(value:Boolean):void{
				_continous = value;
				if(_continous == false) {
					pause(); 
				}
				else {
					resume();
				}
			}
			public function unload():void {
				
			}			
			public function resume():void {
				
			}
			public function pause():void {
				
			}
			public function updateMaxRadius(value:Number):void {
				this.maxRadius = value;
				update();
			}
			public function updateYear(year:int):void {
				this.currentYear = year;
				update();
			
			}
			public function update():void {
				if(dataset.time == 1 && currentYear >= Number(dataset.years[0]) && currentYear <= Number(dataset.years[1])) {
					
					for each(var c:CircleSprite in renderers) {
						var r:Number = (c.data[currentYear] - dataset.min) / (dataset.max - dataset.min) * maxRadius;
						//trace(r);
						TweenNano.to(c, .5, {radius: r});
					}
				}
			}
			public function toggleCategory(prop:String):void {
				mapHolder.removeAllElements();
			}
			public function toggleOpacity(value:uint):void {
				for each(var renderer:CircleSprite in renderers) {
					TweenNano.to(renderer, .5, {alpha: value});
				}
			}
			protected function module1_resizeHandler(event:ResizeEvent):void {
				for each(var c:CircleSprite in renderers) {
					c.x = c.data.xcoord*width/939.747;
					c.y = c.data.ycoord*height/394.863;
				}
				var maxW:Number = 0;
				var widestSprite:Sprite;
				var i:int = 0;
				var child:FXGLoader;
				var fxgSprite:Sprite;
				
				for (i=0;i<mapHolder.numElements;i++) {
					child = mapHolder.getElementAt(i) as FXGLoader;
					fxgSprite = child.fxgSprite;
					child.graphics.clear();
					child.graphics.beginFill(0xff6666,1);
					child.graphics.drawRect(0,0,child.width,child.height);
					child.graphics.endFill();
					var g:Sprite = fxgSprite.getChildAt(0) as Sprite;  
					if(g.width > maxW) {
						maxW = g.width;
						widestSprite = g;
					}
				}
				if(mapHolder.numElements > 0) {
					var nw:Number; var nh:Number;   
					
					var fxgRatio:Number = widestSprite.width / widestSprite.height;
					var ratio:Number = (mapHolder.width*.4)/ mapHolder.height;  
				
					if(ratio >= fxgRatio) {
						nh = mapHolder.height;
						nw = nh*fxgRatio;
					}
					else {
						nw = (mapHolder.width)*.4;
						nh = nw/fxgRatio;
					}
					var sx:Number = nw/widestSprite.width;
					var sy:Number = nh/widestSprite.height;
					
					for (i=0;i<mapHolder.numElements;i++) {
						child = mapHolder.getElementAt(i) as FXGLoader;
						fxgSprite = child.fxgSprite;
						var ptScalePoint:Point = new Point((child.width / 2),(child.height / 2));
						var m:Matrix = widestSprite.transform.matrix;
						m.scale(sx, sy);
						fxgSprite.transform.matrix = m;
						fxgSprite.x = (child.width / 2) - (fxgSprite.width / 2 );
						fxgSprite.y = (child.height / 2) - (fxgSprite.height / 2);
					}
				}
			}
			

			private const PATH:String = "Sites/JWT2001/View/src/assets/maps/"
			protected function module1_creationCompleteHandler(event:FlexEvent):void
			{
				
				var map:FXGLoader = new FXGLoader();
				mapHolder.addElement(map);
				var file:File = File.userDirectory;
				file = file.resolvePath(PATH+"oceania_map.fxg");
				map.load(file);
				map.percentHeight = 100;
				map.percentWidth = 20;
				
				var map:FXGLoader = new FXGLoader();
				mapHolder.addElement(map);
				map.percentHeight = 100;
				map.percentWidth = 	40;
				var file:File = File.userDirectory;
				file = file.resolvePath(PATH+"Namerica_map.fxg");
				map.load(file);
				
				var map:FXGLoader = new FXGLoader();
				mapHolder.addElement(map);
				map.percentHeight = 100;
				map.percentWidth = 40;
				var file:File = File.userDirectory;
				file = file.resolvePath(PATH+"asia_map.fxg");
				map.load(file);	

			}


		]]>
	</fx:Script>
	<fx:Declarations>
		<s:Fade alphaTo="1" duration="500" id="fadeIn" />
		<s:Fade alphaTo="0" duration="500" id="fadeOut" />
	</fx:Declarations>
	
	<s:HGroup width="100%" height="100%"  id="mapHolder" gap="2" />
	<s:Group id="holder" width="100%" height="100%" />
	
</modules:Module>
